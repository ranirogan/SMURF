# SMURF WEEK ONE

Your mission is to get the tests to run (`npm test`). These tests all check the
parsing and evaluation of arithmetic expressions.

You'll be exercising your knowledge of grammars, PEG parsers, ASTs and AST
generation, the Visitor Pattern, and writing an interpreter as a visitor.

## Details

The SMURF grammar has a section describing expressions:

~~~ ebnf
//////////////////// arithmetic expression /////////////////////////////
arithmetic_expression
  = mult_term (addop mult_term)*

mult_term
  = primary (mulop primary)*

primary
  = integer
  | "(" arithmetic_expression ")"
  // | function_call                  // I've commented these
  // | variable_value                 // two out for now

integer
  = ("+" | "-") digits

digits
  = ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+

addop
  = '+' | '-'

mulop
  = '*' | '/'
~~~

Your job is to:

* convert this grammar into something the Peg.js can use (hint: it's close
  already). Put the result into `src/grammar.pegjs`. At this point, you should
  be able to check that your grammar is valid by running `node src/smurf.js
  123`. This won't do anything except use the code I supplied in `smurf.js` to
  load the grammar into peg.js.

* write code in `compiler.js` to get peg.js to parse the SMURF program that is
  passed in using the compiled grammar.

  This will involve creating an AST based on the SMURF source, then writing an
  interpreter that uses the Visitor Pattern to traverse the AST and evaluate it.

* remember to return the value generated by the interpreter

* you can check your progress by running the tests: `npm test`


## Some Suggestions

* Don't Panic. This may seem like a lot, but it has all been covered in the
  course. Take small steps, and get feedback on each before moving on. (By
  feedback, I mean that you should think of ways to test that what you just
  changed works the way you thought it should.)

* When converting the grammar into Peg format, don't bother with whitespace
  initially; just support expressions with no spaces. Then, once that's working,
  go back and add whitespace support to the grammar (the only change will be in `grammar.pegjs`).

* I think there are two smart ways to approach this. Both start by getting the
  the grammar to load into peg.js (ie there are no errors when you run
  smurf.js).

  * *Path 1:* Implement each part of the transformation in turn.

    * write just enough code in `compiler.js` to parse the program you get
      passed. Write the result of the parse to the console. It should be a
      nested array of tokens.

    * Now write the JavaScript classes for `BinOp` and `IntegerValue`. Arrange
      for them to be imported into your grammar, then use the embedded
      JavaScript feature in the peg.js grammar file to create the AST. You
      should be able to see the result on the console: what was previously a
      nested array will not be nested objects.

    * Write an interpreter that acts as a visitor. This will mean writing a
      top-level `visit()` function, along with a visit function for each AST
      node type. You'll need to add an `accept` function to your AST node
      classes. Remember that both the `visit...` functions and the `accept`
      functions must return a value.

    * Call the interpreter from your `compileAndRun` function.

  * *Path 2:* Focus on getting just the simplest part of the grammar to work,
      end to end, then adding more

    * Have an initial grammar that just supports digits. Write the AST class
      `Integervalue`, and return an object of that type from the parse. That's
      now your AST.

    * Write an interpreter that has a top-level `visit` function, along with
      `visitInteger`. Make sure your AST `IntegerValue` class has an `accept()`
      function.

    * Wire all this together, and you should now be able to parse strings such
      as "1" and "12345". Check this by writing the return value from the
      interpreter to the console.

    * Now add support for a leading minus sign by implementing the `integer`
      rule. Make sure that works.

    * Add in the primary rule.

    * Now add `mult_term`. You'll need to add the BinOp AST node at this point,
      and extend your interpreter to support it. You should now be able to
      execute things such as "999", "9*9", "123/3", and so on.

    * Now add `arithmetic_expression` and, once it works, you're done

  * Now, for both paths, add support for whitespace to the grammar.

  * Personally, I tend to prefer the second approach, as it helps me to know how
    everything knits together.

* Commit often.

* Use me if you get stuck.
